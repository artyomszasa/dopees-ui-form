var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var DateRangePicker_1;
import "./date-range-field/date-range-field.js";
import { customElement, property, query, observe } from "@polymer/decorators/lib/decorators.js";
import { sprintf } from "dopees-core/lib/string.js";
import { Picker } from "./picker/picker.js";
let DateRangePicker = DateRangePicker_1 = class DateRangePicker extends Picker {
  constructor() {
    super();
    this.value = {};

    this.selection = () => false;

    this.formatter = x => {
      if (!x) {
        return this.placeholder || '';
      }

      if (x.start) {
        if (x.end) {
          return sprintf('%04d. %02d. %02d -- %04d. %02d. %02d', x.start.year, x.start.month, x.start.day, x.end.year, x.end.month, x.end.day);
        }

        return sprintf('%04d. %02d. %02d', x.start.year, x.start.month, x.start.day);
      }

      if (x.end) {
        return sprintf('%04d. %02d. %02d', x.end.year, x.end.month, x.end.day);
      }

      return this.placeholder || '';
    };
  }

  static get template() {
    return Picker.createTemplate(DateRangePicker_1, {
      implementation: 'dope-date-range-field',
      arguments: {
        years: '[[years]]',
        months: '[[months]]',
        selection: '[[selection]]',
        value: '{{value}}',
        'start-date': '{{startDate}}',
        'end-date': '{{endDate}}'
      }
    });
  }

  activate() {
    this.wrapper.focus();
    this.innerField.activate();
  }

  observeEmpty(value) {
    this.empty = !value;
  }

  valueChanged(value) {
    this.__valueChanging = true;

    try {
      this.startDate = value.start;
      this.endDate = value.end;
    } finally {
      this.__valueChanging = false;
    }
  }

  valuesChanged(start, end) {
    if (start) {
      if (end) {
        this.selection = date => 0 <= date.compareTo(start) && 0 >= date.compareTo(end);
      } else {
        this.selection = date => date.equalsTo(start);
      }
    } else {
      if (end) {
        this.selection = date => date.equalsTo(end);
      } else {
        this.selection = () => false;
      }
    }

    if (!this.__valueChanging) {
      this.value = {
        start,
        end
      };
    }
  }

};

__decorate([property({
  type: Object,
  notify: true
})], DateRangePicker.prototype, "value", void 0);

__decorate([property({
  type: Object,
  notify: true
})], DateRangePicker.prototype, "startDate", void 0);

__decorate([property({
  type: Object,
  notify: true
})], DateRangePicker.prototype, "endDate", void 0);

__decorate([property()], DateRangePicker.prototype, "formatter", void 0);

__decorate([property()], DateRangePicker.prototype, "selection", void 0);

__decorate([query('dope-date-range-field')], DateRangePicker.prototype, "innerField", void 0);

__decorate([observe('value')], DateRangePicker.prototype, "observeEmpty", null);

__decorate([observe('value')], DateRangePicker.prototype, "valueChanged", null);

__decorate([observe('startDate', 'endDate')], DateRangePicker.prototype, "valuesChanged", null);

DateRangePicker = DateRangePicker_1 = __decorate([customElement('dope-date-range-picker')], DateRangePicker);
export { DateRangePicker };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUEyQyxDQUEzQyxDQUFBOztBQUdBLFVBQUEsQ0FBQSxDQURDLFFBQVEsRUFDVCxDQUFBLEUseUJBQUEsRSxXQUFBLEUsS0FBcUQsQ0FBckQsQ0FBQTs7QUFHQSxVQUFBLENBQUEsQ0FEQyxLQUFLLENBQUMsdUJBQUQsQ0FDTixDQUFBLEUseUJBQUEsRSxZQUFBLEUsS0FBdUIsQ0FBdkIsQ0FBQTs7QUEyQkEsVUFBQSxDQUFBLENBREMsT0FBTyxDQUFDLE9BQUQsQ0FDUixDQUFBLEUseUJBQUEsRSxjQUFBLEVBRUMsSUFGRCxDQUFBOztBQUtBLFVBQUEsQ0FBQSxDQURDLE9BQU8sQ0FBQyxPQUFELENBQ1IsQ0FBQSxFLHlCQUFBLEUsY0FBQSxFQVFDLElBUkQsQ0FBQTs7QUFXQSxVQUFBLENBQUEsQ0FEQyxPQUFPLENBQUMsV0FBRCxFQUFjLFNBQWQsQ0FDUixDQUFBLEUseUJBQUEsRSxlQUFBLEVBaUJDLElBakJELENBQUE7O0FBNUVXLGVBQWUsR0FBQSxpQkFBQSxHQUFBLFVBQUEsQ0FBQSxDQUQzQixhQUFhLENBQUMsd0JBQUQsQ0FDYyxDQUFBLEVBQWYsZUFBZSxDQUFmO1NBQUEsZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9kYXRlLXJhbmdlLWZpZWxkL2RhdGUtcmFuZ2UtZmllbGQnO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCwgcHJvcGVydHksIHF1ZXJ5LCBvYnNlcnZlIH0gZnJvbSAnQHBvbHltZXIvZGVjb3JhdG9ycy9saWIvZGVjb3JhdG9ycyc7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2RvcGVlcy1jb3JlL2xpYi9kYXRldGltZSc7XG5pbXBvcnQgeyBzcHJpbnRmIH0gZnJvbSAnZG9wZWVzLWNvcmUvbGliL3N0cmluZyc7XG5pbXBvcnQgeyBWYWx1ZUZpZWxkIH0gZnJvbSAnLi9maWVsZCc7XG5pbXBvcnQgeyBQaWNrZXIgfSBmcm9tICcuL3BpY2tlci9waWNrZXInO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9kYXRlLWZpZWxkL2RhdGUtZmllbGQnO1xuaW1wb3J0IHsgRGF0ZVRpbWVSYW5nZSB9IGZyb20gJy4vZGF0ZS1yYW5nZS1maWVsZC9kYXRlLXJhbmdlLWZpZWxkJztcblxuQGN1c3RvbUVsZW1lbnQoJ2RvcGUtZGF0ZS1yYW5nZS1waWNrZXInKVxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZVBpY2tlciBleHRlbmRzIFBpY2tlcjxEYXRlVGltZVJhbmdlPiBpbXBsZW1lbnRzIFZhbHVlRmllbGQ8RGF0ZVRpbWVSYW5nZT4ge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBQaWNrZXIuY3JlYXRlVGVtcGxhdGUoRGF0ZVJhbmdlUGlja2VyLCB7XG4gICAgICBpbXBsZW1lbnRhdGlvbjogJ2RvcGUtZGF0ZS1yYW5nZS1maWVsZCcsXG4gICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgeWVhcnM6ICdbW3llYXJzXV0nLFxuICAgICAgICBtb250aHM6ICdbW21vbnRoc11dJyxcbiAgICAgICAgc2VsZWN0aW9uOiAnW1tzZWxlY3Rpb25dXScsXG4gICAgICAgIHZhbHVlOiAne3t2YWx1ZX19JyxcbiAgICAgICAgJ3N0YXJ0LWRhdGUnOiAne3tzdGFydERhdGV9fScsXG4gICAgICAgICdlbmQtZGF0ZSc6ICd7e2VuZERhdGV9fSdcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX192YWx1ZUNoYW5naW5nOiBhbnk7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogT2JqZWN0LCBub3RpZnk6IHRydWUgfSlcbiAgdmFsdWU6IERhdGVUaW1lUmFuZ2UgPSB7fTtcblxuICBAcHJvcGVydHkoe3R5cGU6IE9iamVjdCwgbm90aWZ5OiB0cnVlIH0pXG4gIHN0YXJ0RGF0ZTogRGF0ZVRpbWV8dW5kZWZpbmVkO1xuXG4gIEBwcm9wZXJ0eSh7dHlwZTogT2JqZWN0LCBub3RpZnk6IHRydWUgfSlcbiAgZW5kRGF0ZTogRGF0ZVRpbWV8dW5kZWZpbmVkO1xuXG4gIEBwcm9wZXJ0eSgpXG4gIGZvcm1hdHRlcjogKGl0ZW06IERhdGVUaW1lUmFuZ2UpID0+IHN0cmluZztcblxuICBAcHJvcGVydHkoKVxuICBzZWxlY3Rpb246IChkYXRlOiBEYXRlVGltZSkgPT4gYm9vbGVhbiA9ICgpID0+IGZhbHNlO1xuXG4gIEBxdWVyeSgnZG9wZS1kYXRlLXJhbmdlLWZpZWxkJylcbiAgaW5uZXJGaWVsZCE6IERhdGVGaWVsZDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm9ybWF0dGVyID0geCA9PiB7XG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgICB9XG4gICAgICBpZiAoeC5zdGFydCkge1xuICAgICAgICBpZiAoeC5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gc3ByaW50ZignJTA0ZC4gJTAyZC4gJTAyZCAtLSAlMDRkLiAlMDJkLiAlMDJkJywgeC5zdGFydC55ZWFyLCB4LnN0YXJ0Lm1vbnRoLCB4LnN0YXJ0LmRheSwgeC5lbmQueWVhciwgeC5lbmQubW9udGgsIHguZW5kLmRheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwcmludGYoJyUwNGQuICUwMmQuICUwMmQnLCB4LnN0YXJ0LnllYXIsIHguc3RhcnQubW9udGgsIHguc3RhcnQuZGF5KTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmVuZCkge1xuICAgICAgICByZXR1cm4gc3ByaW50ZignJTA0ZC4gJTAyZC4gJTAyZCcsIHguZW5kLnllYXIsIHguZW5kLm1vbnRoLCB4LmVuZC5kYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgfTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMud3JhcHBlci5mb2N1cygpO1xuICAgIHRoaXMuaW5uZXJGaWVsZC5hY3RpdmF0ZSgpO1xuICB9XG5cbiAgQG9ic2VydmUoJ3ZhbHVlJylcbiAgb2JzZXJ2ZUVtcHR5KHZhbHVlOiBEYXRlVGltZXx1bmRlZmluZWQpIHtcbiAgICB0aGlzLmVtcHR5ID0gIXZhbHVlO1xuICB9XG5cbiAgQG9ic2VydmUoJ3ZhbHVlJylcbiAgdmFsdWVDaGFuZ2VkKHZhbHVlOiBEYXRlVGltZVJhbmdlKSB7XG4gICAgdGhpcy5fX3ZhbHVlQ2hhbmdpbmcgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHZhbHVlLnN0YXJ0O1xuICAgICAgdGhpcy5lbmREYXRlID0gdmFsdWUuZW5kO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9fdmFsdWVDaGFuZ2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIEBvYnNlcnZlKCdzdGFydERhdGUnLCAnZW5kRGF0ZScpXG4gIHZhbHVlc0NoYW5nZWQoc3RhcnQ6IERhdGVUaW1lfHVuZGVmaW5lZCwgZW5kOiBEYXRlVGltZXx1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSAoZGF0ZTogRGF0ZVRpbWUpID0+IDAgPD0gZGF0ZS5jb21wYXJlVG8oc3RhcnQpICYmIDAgPj0gZGF0ZS5jb21wYXJlVG8oZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gKGRhdGU6IERhdGVUaW1lKSA9PiBkYXRlLmVxdWFsc1RvKHN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IChkYXRlOiBEYXRlVGltZSkgPT4gZGF0ZS5lcXVhbHNUbyhlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9fdmFsdWVDaGFuZ2luZykge1xuICAgICAgdGhpcy52YWx1ZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgfVxufSJdLCJzb3VyY2VSb290IjoiIn0=